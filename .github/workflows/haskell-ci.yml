name: Haskell CI

on:
  push:
    tags:
      - '*'
  pull_request:
    branches:
      - '**'
    paths:
      - '.env'
      - 'src/**'
      - 'test/**'
      - 'Dockerfile'
      - 'haskell.cabal'
      - '.github/workflows/haskell.yml'

jobs:
  # -------------------------
  # Build and Test Haskell
  # -------------------------
  build-and-test:
    name: ğŸš€ Build and Test Haskell
    runs-on: ubuntu-latest
    env:
      GHC_VERSION: "9.8.2"
      CABAL_VERSION: "3.10.2.0"
      GHCR_REPO: ghcr.io/lmrco/haskell
      GOOGLE_REPO: docker
      GOOGLE_REGISTRY: europe-west6-docker.pkg.dev
      GOOGLE_PROJECT_ID: nimble-repeater-462408-j7
      TEST_REPORT_DIR: test-reports
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: â™»ï¸ Export Runtime Environment variables
        run: |
          GHCR_REPO=ghcr.io/lmrco/haskell
          echo "GHCR_REPO=$GHCR_REPO" >> $GITHUB_ENV
          GOOGLE_REPO=docker
          echo "GOOGLE_REPO=$GOOGLE_REPO" >> $GITHUB_ENV
          GOOGLE_REGISTRY=europe-west6-docker.pkg.dev
          echo "GOOGLE_REGISTRY=$GOOGLE_REGISTRY" >> $GITHUB_ENV
          GOOGLE_PROJECT_ID=nimble-repeater-462408-j7
          echo "GOOGLE_PROJECT_ID=$GOOGLE_PROJECT_ID" >> $GITHUB_ENV
          echo "PROJECT_VERSION=$PROJECT_VERSION" >> $GITHUB_ENV
          BUILD_IMAGE_TAG=$(sha256sum haskell.cabal | cut -c1-64)
          echo "BUILD_IMAGE_TAG=$BUILD_IMAGE_TAG" >> $GITHUB_ENV
          PROJECT_VERSION=$(cat VERSION)
          echo "PROJECT_VERSION=$PROJECT_VERSION" >> $GITHUB_ENV
          DEVELOPMENT_VERSION=0.0.1.3
          echo "DEVELOPMENT_VERSION=$DEVELOPMENT_VERSION" >> $GITHUB_ENV
          BRANCH_NAME=$(echo "${{ github.head_ref }}" | sed -E 's#^(chore|feature|bugfix|hotfix|release)/##' | sed 's/\//-/g')
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV
          GHCUP_INSTALL_BASE_PREFIX=$HOME
          echo "GHCUP_INSTALL_BASE_PREFIX=$GHCUP_INSTALL_BASE_PREFIX" >> $GITHUB_ENV
          INDEX_STATE=2025-04-08T10:52:25Z
          echo "INDEX_STATE=$INDEX_STATE" >> $GITHUB_ENV

      - name: ğŸ” Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_TOKEN }}

      - name: ğŸ” Check if Docker image exists
        run: |
          echo "Checking if Docker image ghcr.io/lmrco/haskell-builder:${{ env.DEVELOPMENT_VERSION }} exists..."
          if docker manifest inspect ghcr.io/lmrco/haskell-builder:${{ env.DEVELOPMENT_VERSION }} > /dev/null 2>&1; then
            echo "âœ… Docker image exists."
            echo "DOCKER_IMAGE_EXISTS=true" >> $GITHUB_ENV
          else
            echo "âŒ Docker image does not exist, will build a new one."
            echo "DOCKER_IMAGE_EXISTS=false" >> $GITHUB_ENV
          fi

      - name: ğŸ”§ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ğŸ› ï¸ Build Development Docker Image
        if: env.DOCKER_IMAGE_EXISTS == 'false'
        run: |
          docker buildx build \
          --push \
          --platform linux/amd64 \
          --target dev \
          -t ${{ env.GHCR_REPO }}-builder:${{ env.DEVELOPMENT_VERSION }} \
          -f Dockerfile .

      - name: ğŸ³ Pull Development Docker Image
        run: |
          docker pull ${{ env.GHCR_REPO }}-builder:${{ env.DEVELOPMENT_VERSION }} || true

      - name: ğŸ›  Build Haskell Server in Development Image
        continue-on-error: true
        run: |
          docker run --rm \
            -w /work \
            -v $(pwd):/work \
            --user $(id -u):$(id -g) \
            ${{ env.GHCR_REPO }}-builder:${{ env.DEVELOPMENT_VERSION }} \
            cabal build all

      - name: ğŸ“¦ Save server binary as artifact
        uses: actions/upload-artifact@v4
        with:
          name: haskell-server
          path: ./bin/haskell-server

      - name: Cache Cabal Store
        uses: actions/cache@v3
        with:
          path: |
            ~/.cabal/store
            ./dist-newstyle
          key: cabal-store-${{ hashFiles('cabal.project') }}-${{ hashFiles('cabal.project.freeze') }}

      - name: ğŸ”§ Cache Haskell Toolchain
        id: haskell-cache
        uses: actions/cache@v3
        with:
          path: |
            /home/runner/.ghcup
            /home/runner/.cabal
          key: haskell-toolchain-${{ hashFiles('haskell.cabal') }}
          restore-keys: |
            haskell-toolchain-

      - name: ğŸŒŸ Set up Haskell environment
        if: steps.haskell-cache.outputs.cache-hit != 'true'
        run: |
          curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org  | sh
          source ~/.ghcup/env
          ghcup install ghc ${{ env.GHC_VERSION }}
          ghcup set ghc ${{ env.GHC_VERSION }}
          ghcup install cabal ${{ env.CABAL_VERSION }}
          cabal update --index-state='hackage.haskell.org ${{ env.INDEX_STATE }}, cardano-haskell-packages ${{ env.INDEX_STATE }}'
          ghc --version
          cabal --version
          echo "$HOME/.ghcup/bin" >> $GITHUB_PATH
          echo "$HOME/.cabal/bin" >> $GITHUB_PATH

      - name: ğŸ›  Build Haskell Server
        run: |
          cabal build all
          mkdir -p ./bin
          cp ./dist-newstyle/build/aarch64-osx/ghc-8.10.7/haskell-${PROJECT_VERSION}/x/haskell-server/build/haskell-server/haskell-server ./bin/haskell-server

      - name: ğŸ“¦ Save server binary as artifact
        uses: actions/upload-artifact@v4
        with:
          name: haskell-server
          path: ./bin/haskell-server

      - name: ğŸ§ª Run Unit Tests and Generate Report
        run: |
          export TASTY_ANT_XML=${TEST_REPORT_DIR}/hspec-results.xml
          cabal test haskell:haskell-unit-tests --test-show-details=direct --test-option=--xml-output

      - name: ğŸ“¤ Upload test report
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: ${{ env.TEST_REPORT_DIR }}/hspec-results.xml

#      - name: ğŸ§¾ Publish test results to GitHub UI
#        uses: mikepenz/action-junit-report@v4
#        if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository
#        with:
#          report_paths: ${{ env.TEST_REPORT_DIR }}/hspec-results.xml
#          include_passed: true

#      - name: ğŸ“‹ Post test results as PR comment
#        uses: dorny/test-reporter@v1
#        if: github.event_name == 'pull_request'
#        continue-on-error: true
#        with:
#          name: Unit Tests Reports
#          path: ${{ env.TEST_REPORT_DIR }}/hspec-results.xml
#          reporter: java-junit
#          fail-on-error: false

      - name: ğŸ§ª Run Integration Tests and Generate Report
        run: |
          cabal run haskell:haskell-server &
          sleep 2
          export TASTY_ANT_XML=test-reports/hspec-results.xml
          cabal test haskell:haskell-integration-tests --test-show-details=direct --test-option=--xml-output
          kill $(jobs -p)

      - name: ğŸ“¤ Upload integration test report
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-results
          path: ${{ env.TEST-REPORT_DIR }}/hspec-results-integrations.xml

#      - name: ğŸ§¾ Publish integration test results to GitHub UI
#        uses: mikepenz/action-junit-report@v4
#        if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository
#        with:
#          report_paths: ${{ env.TEST_REPORT_DIR }}/hspec-results-integration.xml
#          include_passed: true

#      - name: ğŸ“‹ Post integration test results as PR comment
#        uses: dorny/test-reporter@v1
#        if: github.event_name == 'pull_request'
#        continue-on-error: true
#        with:
#          name: Integration Tests Reports
#          path: ${{ env.TEST_REPORT_DIR }}/hspec-results-integration.xml
#          reporter: java-junit
#          fail-on-error: false

      - name: ğŸ“¥ Download built binary
        uses: actions/download-artifact@v4
        with:
          name: haskell-server
          path: ./bin

      - name: ğŸ” Log in to Google Artifact Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.GOOGLE_REGISTRY }}/${{ env.GOOGLE_PROJECT_ID }}/${{ env.GOOGLE_REPO }}
          username: _json_key
          password: ${{ secrets.GOOGLE_ARTIFACT_REGISTRY_JSON_KEY }}

      - name: ğŸ³ Build Server Image & Push
        run: |
          docker buildx build \
            --push \
            --target server \
            --platform linux/amd64 \
            --build-arg HOST_UID=$(shell id -u) \
            --build-arg HOST_GID=$(shell id -g) \
            --build-arg BINARY_PATH=./bin/haskell-server \
            -t "$GHCR_REPO-server:$PROJECT_VERSION-$BRANCH_NAME" \
            -t "$GOOGLE_REGISTRY/$GOOGLE_PROJECT_ID/$GOOGLE_REPO/haskell-server:$BRANCH_NAME" \
            -f Dockerfile .

      - name: ğŸ§ª Pull Server Docker Image
        run: |
          docker pull "$GHCR_REPO-server:$PROJECT_VERSION-$BRANCH_NAME"

      - name: ğŸ§ª Start Server Docker Image
        run: |
          # Start the container in detached mode
          docker run -d --rm --name haskell-server -p 8080:8080 "$GHCR_REPO-server:$PROJECT_VERSION-$BRANCH_NAME"
          # Wait for the server to start
          echo "â³ Waiting for server to be ready..."
          for i in {1..10}; do
            if curl -sSf http://localhost:8080/health > /dev/null; then
              break
            fi
            echo "Still waiting... (${i}s)"
            sleep 3
          done
          # Check logs if the server fails to start
          if ! curl -sSf http://localhost:8080/health > /dev/null; then
            echo "âŒ Server failed to start. Checking logs..."
            docker logs haskell-server
            exit 1
          fi
          echo "âœ… Server is running"

      - name: ğŸ§ª Test Server Docker Image
        run: |
          cabal test haskell:haskell-integration-tests

      - name: ğŸ§ª Stop Server Docker Image
        run: |
          docker stop haskell-server

      - name: ğŸ” Authenticate with Google Cloud
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GOOGLE_ARTIFACT_REGISTRY_JSON_KEY }}

      - name: ğŸš¢ Deploy to Cloud Run
        uses: google-github-actions/deploy-cloudrun@v1
        with:
          region: europe-west6
          service: haskell-server-${{ env.BRANCH_NAME }}
          image: ${{ env.GOOGLE_REGISTRY }}/${{ env.GOOGLE_PROJECT_ID }}/${{ env.GOOGLE_REPO }}/haskell-server:${{ env.BRANCH_NAME }}
          project_id: ${{ env.GOOGLE_PROJECT_ID }}
          allow_unauthenticated: true

      - name: ğŸ”§ Install HLint
        run: |
          cabal install hlint

      - name: ğŸ”§ Install Fourmolu
        run: |
          cabal install fourmolu

      - name: ğŸ” Lint Haskell code (HLint)
        run: |
          hlint app/ src/ test/

      - name: ğŸ¨ Format Haskell code (Fourmolu)
        run: |
          find app/ src/ test/ -name '*.hs' | xargs fourmolu --mode check
          
      - name: ğŸ“š Build Haddock documentation
        run: |
          cabal haddock --haddock-html --haddock-hyperlink-source

      - name: ğŸ“‚ Copy generated docs
        run: |
          mkdir -p generated-docs
          DOCS_PATH=$(find dist-newstyle/build -type d -path "*/doc/html/*" -name haskell | head -n 1)
          if [ -z "$DOCS_PATH" ]; then
            echo "âŒ Failed to locate generated docs"
            exit 1
          fi
          cp -r "$DOCS_PATH"/* generated-docs/

      - name: ğŸš€ Deploy Haddock Docs to GitHub Pages
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GHCR_TOKEN }}
          publish_dir: ./generated-docs
          publish_branch: gh-pages
          destination_dir: ${{ github.ref_name }}
